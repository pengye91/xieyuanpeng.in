# Redis学习22

**任务队列**

可以使用`Redis`的`List`实现一个简易的任务队列

### 关于BLPOP

在`Redis`中，有一些阻塞命令，并且可以带有`timeout`超时限制，在使用的过程中，一定要注意：

- **确定连接的超时限制**。

如果连接的超时小于阻塞命令的超时，在等待返回结果的时候，连接可能会断掉（根据不同客户端的设置情况而定）。


### 多任务

- 可以每种任务一个队列
	好做。
	
- 一个队列多种任务
	虽然没必要。
	
	**思路**：
	
	- 先将所有需要延后执行的函数注册在一个容器中(可以是列表啊，切片啊，最好是字典，视客户端而定)；
	
	- （线程A）向队列中push的内容为`["FUNCTION_NAME", [ARG1, ARG2, ..., ARGN]]`（可以用JSON编码）；
	
	- （线程B）解码从队列中取出来的内容：
	
		1. 将`FUNCTION_NAME`和回调函数映射中的键对比得到真的回调函数。
		2. 用真实的函数运行所有`ARGS`。
		3. 可以视需求决定添加任务`ID`，返回结果等细节。
		
### 优先队列

由于`BLPOP`等阻塞命令可以接受多个列表，其原则是：

- `BLPOP key1 key2 key3... timeout`
- 当`key1`有元素，就弹出；
- `key1`没有，若`key2`有，就弹出`key2`的...一直到所有的`key`都没有。

所以可以使用多个`LIST`实现简单的优先队列。

### 延迟任务

**方法**：

- 将所有需要延时执行的任务添加到`Redis`中的有序集合里，并且将任务的执行时间设置为分值。另开一个线程来查找有序集合里面是否有可以立即被执行的任务，如果有，从集合里移除并将其添加到合适的任务队列里。

	延迟任务可以**定义**为如下：
	
		{
		"ID": "xxxx-xxxxx-xxxxxx-xxxx-xxxx",
		"queue": "QUEUE_NAME",
		"functionName": "FUNCTION_NAME",
		"args": ["arg1", "arg2"]
		}

	其JSON编码为成员，被执行时间的Unix时间戳为分值。
	
	**执行**
	
	另起一个线程，轮询有序集合里面分值小于当前时间戳的任务：
	
	- 如果没有，则等待并重试；
	- 如果有，先用任务`ID`获取一个细粒度锁，再将其全部送往合适的`queue`里，再将其删除。
	
	*问题*
	这样有一个问题，就是所有的操作都是通过应用层的代码进行的控制，感觉略复杂。
	



